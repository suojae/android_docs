공식문서 링크<br/>
[https://developer.android.com/topic/architecture](https://developer.android.com/topic/architecture)

<br/>

## Guide to app arhciteture

<br/>

### Mobile app user experiences

<img src="https://github.com/suojae3/android_kotlin_docs/assets/126137760/638a1ff4-fc03-41b2-9d62-af9ca6bf6da3" width="450">

<br/>
<br/>

#### 🔫 안드로이드는 다양한 컴포넌트들로 구성되어 있다.(그중 주요 4대 컴포넌트는 아래와 같다)
- `activities`: 사용자 인터페이스(UI)를 구성하는 화면(사용자와 애플리케이션이 상호작용할 수 있는 단일 화면)
- `fragments`: 전체 UI에서 어딘가에 반복적으로 재사용 가능한 부분
- `services`: 사용자와 상호작용하지 않고 백그라운드에서 오래 실행되는 작업을 수행할 수 있는 애플리케이션 구성 요소
- `content provider`: 다른 애플리케이션의 데이터에 접근이 필요할 때 사용하게 되는 컴포넌트(ex: 사진첩)
- 이러한 컴포넌트들은 `app manifest`에 정보를 담게된다.
  
<br/>

#

### Common architectural principles

#### 🔫 Separation of concerns
- UI관련 요소에는 UI 핸들링 로직만 담겨 있어야한다.
- 관심사의 분리 강조!


#### 🔫 Drive UI from data models
- UI는 데이터 모델링에 따라 바뀌어야한다. 즉 데이터모델이 UI에 의존하는 것이 아니라 UI가 데이터모델에 의존해야한다.
- 위와같이 설계해야 데이터가 UI라이프사이클로부터 독립적일 수 있다. (OS가 메모리가 부족하면 UI라이프사이클에 관여하기 때문)
- 따라서 OS가 앱을 강제종료시키더라도 데이터모델은 이로부터 독립적이여야한다.
- 네트워크 환경 여부와도 독립적이여야한다. (OS가 관여할 수 있는 영역이기 때문에)


#### 🔫 Single source of truth
- SSOT는 데이터를 소유하고 있는 객체로 오직 SSOT만이 데이터를 수정할 수 있다.
- 외부에서 참조가 아닌 SSOT 자체에서 변환을 끝내야하기 때문에 SSOT는 "불변"타입의 데이터를 뿌리게된다.
- 즉 인풋으로 이벤트가 SSOT에 들어오면 SSOT 내부 블랙박스에서 데이터를 조작한뒤 아웃풋으로 불변 데이터 모델을 뿌리는 방식이다.
- 이를 통해 데이터를 한 곳에 집중시키고 보호할 수 있다.



#### 🔫 Unidirectional Data Flow
- SSOT는 보통 단방향으로 많이 구현된다. 어찌보면 당연한게 SSOT자체가 한쪽으로 이벤트가 들어와서 한쪽으로 바뀐 데이터를 뱉어서 이걸 UI가 반영하는 것이기 때문이다.
- 즉 안드공식문서에서는 데이터는 상위에서 하위계층으로 이벤트는 하위에서 상위 계층으로 흐르게 하는 것을 권장하고 있다. (트리구조를 생각해보면 될듯하다)
- 단방향 패턴을 통해 SSOT의 장점을 최대로 살릴 수 있고 데이터 일관성을 보장할 수 있다.

<br/>

#

### Recommended app architecture

#### 🔫 Modern App Architecture

<img width="400" alt="image" src="https://github.com/suojae3/android_kotlin_docs/assets/126137760/32d53b4e-b35e-415b-b6e5-81ebb70f9259">

- UI 레이어는 데이터를 스크린에 띄우는 곳
- 데이터레이어는 비즈니스 로직을 담고 데이터를 방출하는 곳
- 둘 사이에 인터페이스처럼 도메인 레이어를 만들 수 있지만 이건 옵션사항!

#### 🔫 UI Layer

<img width="400" alt="image" src="https://github.com/suojae3/android_kotlin_docs/assets/126137760/6cd1976e-3c45-452b-b87d-64518f6c5ba7">

- UILayer는 UI 요소와 상태를 담아두는 곳이라고 할 수 있다.
- 이때 `UIElement`는 컴포즈, `State holders`는 viewmodel 로 자주 사용된다.

#### 🔫 Data Layer

<img width="400" alt="image" src="https://github.com/suojae3/android_kotlin_docs/assets/126137760/57d7666d-b322-428f-a342-73d071a16d03">

- 데이터 레이어에는 비즈니스 로직이 담기게 된다. 이때 비즈니스 로직이란 어떤 데이터를 앱에 줄 것이냐이다. 즉 데이터를 어떻게 만들고, 저장하고, 바꿀지에 대한 규칙을 담게된다.
-  앞서 SSOT가 사용자 이벤트에 따라 상태관리를 한다면 레포지토리에서는 I/O 작업에 따른 상태관리를 하게된다.
- 각 데이터 유형에 대해 별도의 리포지토리 클래스를 생성해야 한다. 예를 들어, 영화 데이터와 관련된 `MoviesRepository`, 결제 데이터와 관련된 `PaymentsRepository`를 생성할 수 있다.
- 데이터 소스 객체는 오직 하나의 소스만 책임져야한다(단일책임원칙) 예를들어 네트워크면 네트워크, DB면 DB.

#### 🔫 Domain Layer
- 도메인 레이어는 비즈니스 로직을 캡슐화해서 재사용성을 높이는 책임을 가지고 있다. (뷰모델이 함수를 가져다 씀에 있어 재사용성을 up시킨다)
- 복잡성과 재사용성을 고려해 도메인 레이어는 도입하지 않아도 괜찮다.
- 도메인 레이어내 유즈케이스는 오직 하나의 기능만 가져야한다.



#### 🔫 Manage dependencies between components

- DI는 클래스가 자신이 필요로 하는 의존성을 직접 생성하지 않고 외부에서 주입받도록 하는 디자인 패턴이다. 객체 간의 결합도를 낮추고 코드의 유연성과 테스트 용이성을 높이는 데 기여한다.
- 서비스 로케이터는 의존성을 제공하는 중앙 레지스트리이다. 모든 의존성을 미리 등록해 두고, 필요한 클래스가 의존성을 요청하면 제공한다. (런타임에서 의존성 주입된 객체 제공)
- 안드 공식문서에서는 Hilt 라이브러리를 추천하는데 이유는 컴파일타임에서 의존성 관리를 할 수 있기 때문이다. (서비스 로케이터는 지양하자)


<br/>

#

### General best practices

#### 🔫 안드 공식에서 추천해주는 설계방식 소개
- app component에 데이터를 저장하지 말것: 앞서 살펴본 4대 컴포넌트같이 유저와 맞닿아있는 곳엔 데이터를 저장해두지 않는다. (데이터의 생명은 UI보다 길어야한다)
- 클래스간 의존성을 최소화할 것! 
- 다양한 모듈간 경계 명확히하기: 책임과 역할을 분명하게 구분하기
- 각 모듈간 교환되는 정보를 최소화하기: 특히 설계하다 귀찮다고 객체간 지름길을 놓으면 안된다.
- 앱의 비즈니스 로직에 집중하기: 남이 만들어놓은거, 특히 제트팩 라이브러리를 활용해서 얻은 시간을 비즈니스 로직에 집중해라!
- 테스트하기 좋은 코드를 생각하면서 독립적인 객체들 만들기: 
- 객체의 타입은 동시성 정책에 대한 책임을 가지고 있다: 각 타입을 선언할 때 메인스레드가 안전한지, 역할에 맞게 백그라운드 스레드로 보내지는지 설정해야한다.
- 최대한 최신데이터를 보존해둘 것: 네트워크 환경이 수시로 나빠질 수도 있기때문에 네트워크든 DB든 최대한 최신데이터를 유지해두는 것이 좋다.


